<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Kubernetes 환경 CD(Continuous Deployment) 개선하기 by Derek - Soomgo Tech</title><meta name="gridsome:hash" content="c670d5ee025030f952f3448986aec25d458077d1"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.19"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.f2d543711ef5e20a474f3b69d3d41be5.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.f2d543711ef5e20a474f3b69d3d41be5.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.f2d543711ef5e20a474f3b69d3d41be5.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.f2d543711ef5e20a474f3b69d3d41be5.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.f2d543711ef5e20a474f3b69d3d41be5.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.f2d543711ef5e20a474f3b69d3d41be5.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.f2d543711ef5e20a474f3b69d3d41be5.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.f2d543711ef5e20a474f3b69d3d41be5.png"><link rel="preload" href="/assets/css/0.styles.7d01e712.css" as="style"><link rel="preload" href="/assets/js/app.fa1010ad.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.77e0a7ac.js" as="script"><link rel="prefetch" href="/assets/js/8.6a25e241.js"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.c9645e1f.js"><link rel="prefetch" href="/assets/js/page--src--pages--about-vue.64179064.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.455be179.js"><link rel="prefetch" href="/assets/js/page--src--templates--author-vue.60778b21.js"><link rel="prefetch" href="/assets/js/page--src--templates--tag-vue.bfe6ca6f.js"><link rel="stylesheet" href="/assets/css/0.styles.7d01e712.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="layout"><div class="nav"><nav role="navigation" aria-label="main navigation" class="navbar container nav"><div class="navbar-brand"><a href="/" to="[object Object]" class="navbar-item router-link-active"><img src="/assets/img/soomgo.f2d54371.png" alt="Soomgo"></a><a role="button" aria-label="menu" class="navbar-burger burger"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-start"><a href="/about" to="/about" class="navbar-item">
        About
      </a><a href="https://soomgo.recruitee.com/" class="navbar-item">
        Support
      </a></div><div class="navbar-end"></div></div></nav></div><section class="hero is-medium is-primary"><div class="hero-body"><div class="container"><div class="titles"><h1 class="title is-1">
            Kubernetes 환경 CD(Continuous Deployment) 개선하기
          </h1><h2 class="subtitle">
            About Kubernetes CD
          </h2></div></div></div></section><main><div class="box breadcrumbs"><nav aria-label="breadcrumbs" class="breadcrumb is-centered"><ul><li><a href="/" class="router-link-active">Home</a></li><li class="is-active"><a href="#" aria-current="page">Kubernetes 환경 CD(Continuous Deployment) 개선하기</a></li></ul></nav></div><section class="section"><div class="container"><div class="content"><div><p>안녕하세요. 숨고 DevOps 엔지니어 Derek 입니다.</p>
<p>최근 진행한 Kubernetes 환경에 대한 CD(Continuous Deployment)개선에 대하여 개선 이유, 작업 내용, 결과를 포스팅 해보려 합니다.</p>
<p>동일한 고민을 갖고있을 DevOps 엔지니어 또는 개발자에게 조금이나마 도움이 되길 바랍니다.</p>
<h1 id="1-배경-설명"><a href="#1-%EB%B0%B0%EA%B2%BD-%EC%84%A4%EB%AA%85" aria-hidden="true"><span class="icon icon-link"></span></a>1. 배경 설명</h1>
<p>숨고 서비스를 지탱하는 Application 중 다수의 것들이 Kubernetes 환경에서 운영되고 있습니다. MSA Architecture 로 설계 되어 있으며, 때문에 잘게 나누어진 Application Repository 가 존재합니다. Kubernetes 에 배포를 위한 Manifest 파일은 해당 Application Repository 에 함께 존재했습니다.
숨고는 CI/CD 를 위해 Bitbucket Pipeline 을 사용하고 있습니다. 때문에 도커 이미지 빌드, Kubernetes 배포 또한 Bitbucket Pipeline 을 통하여 진행됩니다. 또한 무 중단 배포를 위한 Blue/Green 배포 스크립트가 존재하고 Bitbucket Pipeline 에서 해당 스크립트를 실행하여 배포하게 됩니다.</p>
<h1 id="2-개선-이유"><a href="#2-%EA%B0%9C%EC%84%A0-%EC%9D%B4%EC%9C%A0" aria-hidden="true"><span class="icon icon-link"></span></a>2. 개선 이유</h1>
<h3 id="21-application-code-와-manifest-file-의-repository-분리"><a href="#21-application-code-%EC%99%80-manifest-file-%EC%9D%98-repository-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="icon icon-link"></span></a>2–1. Application Code 와 Manifest File 의 Repository 분리</h3>
<p>앞서 배경 설명에서 언급 하였듯이 Application Code 와 Manifest 파일이 동일한 Repository 에서 관리 되었습니다. 이는 다음과 같은 단점을 갖고 있었고 이를 분리하여 문제를 해결하고자 했습니다.</p>
<ul>
<li>Manifest File 만 변경시에도 안전한 배포(무중단)를 위해서는 컨테이너 빌드 절차를 거쳐야함. (Kubernetes에서 변경이 있을경우 Rollout 되는 항목에 한하여)</li>
<li>Manifest File 이 여러 Application Repository 에 분산되어 관리가 어려움.</li>
<li>Application Code 변경 로그와 Manifest 변경 로그가 뒤섞여 가시성 떨어짐.</li>
<li>Repository 수정 권한이 있는 모든 인원이 Manifest 파일을 수정하고 이를 Production 까지 적용할 수 있어 안정성이 떨어짐.</li>
</ul>
<h3 id="2-2-gitops-적용"><a href="#2-2-gitops-%EC%A0%81%EC%9A%A9" aria-hidden="true"><span class="icon icon-link"></span></a>2-2. GitOps 적용</h3>
<p>GitOps 란 Kubernetes 클러스터를 관리하고 Application 을 배포하는 방법론이며, 이것은 선언적 인프라와 Application을 위해 Git 을 단일 소스(single source of truth) 로 사용하는것을 말합니다.</p>
<p>즉, 설정파일 관리 Repository (Git) 을 통해서만(단일한 방법) Kuberentes 클러스터가 변경되고 Application이 배포되는 것입니다.</p>
<p>GitOps 적용으로 인한 장점은 다음과 같습니다.</p>
<ul>
<li>Git Repository의 현재 상태만 확인하면 Kubernetes 클러스터의 상태를 쉽게 확인가능.</li>
<li>모든 설정 정보 변경이 Git의 버전으로 관리됨.</li>
<li>kubectl, helm 등의 명령어를 사용자가 직접 실행하는 것이 아니기 때문에 휴먼 에러를 방지하며 안정적으로 상태를 변경하고 배포할수 있음.</li>
<li>Repository 권한 설정으로 Kubernetes 클러스터 접근 권한 분리 가능.</li>
</ul>
<p>이와 같은 장점을 위해 GitOps를 적용하고자 했습니다.</p>
<h3 id="2-3-배포-모니터링-개선"><a href="#2-3-%EB%B0%B0%ED%8F%AC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B0%9C%EC%84%A0" aria-hidden="true"><span class="icon icon-link"></span></a>2-3. 배포 모니터링 개선</h3>
<p>현 배포 시스템의 경우(Bitbucket Pipeline) Kubernetes에 명령을 실행한후 적용이 완료 되었는지 또는 실패 하였는지 등의 모니터링이 되지 않습니다.</p>
<p>ArgoCD 를 사용하여 배포 모니터링을 개선하고자 하였습니다.</p>
<h1 id="3-작업-내용"><a href="#3-%EC%9E%91%EC%97%85-%EB%82%B4%EC%9A%A9" aria-hidden="true"><span class="icon icon-link"></span></a>3. 작업 내용</h1>
<h3 id="31-개선-방향-설정"><a href="#31-%EA%B0%9C%EC%84%A0-%EB%B0%A9%ED%96%A5-%EC%84%A4%EC%A0%95" aria-hidden="true"><span class="icon icon-link"></span></a>3–1. 개선 방향 설정</h3>
<p>앞서 얘기한 현시점의 배포 문제점과 새로 제안한 개선점들을 통하여 실제 작업 내용을 Flow Chart로 만들어봤습니다.</p>
<p>아래 As-Is, To-Be Flow 그림에서 확인할 수 있듯이 Repository 를 분리하고 Manifest Repository 에 변경이 발생하였을때 ArgoCD 에서 이를 감지하여 Sync (배포 or 변경) 하고자 하였습니다.</p>
<ol>
<li>As-Is flow</li>
</ol>
<p><img src="https://miro.medium.com/max/700/1*Z-TOA6-TpZEyZj0q7C4dWQ.jpeg"></p>
<ol start="2">
<li>To-Be flow</li>
</ol>
<p><img src="https://miro.medium.com/max/700/1*5Cs42Py-NVIQsOtoXxlCyA.jpeg"></p>
<h3 id="3-2-manifest-repository-생성"><a href="#3-2-manifest-repository-%EC%83%9D%EC%84%B1" aria-hidden="true"><span class="icon icon-link"></span></a>3-2. Manifest Repository 생성</h3>
<p>Application Respository 에서 Manifest 를 분리하기 위해 통합된 Manifest Repository 를 생성하였습니다. 해당 Repository 는 Helm Chart 를 사용하여 구조화 하였습니다.</p>
<pre class="language-text"><code class="language-text">├── api-gateway #Application 별 Directory
│ ├── Chart.yaml
│ ├── charts
│ ├── dev.values.yaml #환경별 Values 파일
│ ├── prod.values.yaml
│ ├── qa.values.yaml
│ ├── staging.values.yaml
│ ├── templates #Application Templates
│ │ ├── deployment.yaml
│ │ ├── hpa.yaml
│ │ ├── ingress.yaml
│ │ ├── service-standby.yaml
│ │ └── service.yaml
│ └── test.values.yaml
....</code></pre>
<p>해당 Repository 는 배포 환경별 Branch 가 존재합니다. 예를 들어 Staging 배포를 위한 staging branch, QA 환경 배포를 위한 QA branch, Production 배포를 위한 Master branch 와 같은 형태입니다.</p>
<h3 id="3-2-argocd-argo-rollouts-argocd-notifications-사용"><a href="#3-2-argocd-argo-rollouts-argocd-notifications-%EC%82%AC%EC%9A%A9" aria-hidden="true"><span class="icon icon-link"></span></a>3-2. ArgoCD, Argo-rollouts, ArgoCD-notifications 사용</h3>
<p>앞서 언급 하였듯이 배포 개선을 하기위하여 GitOps 의 구현체로 ArgoCD 를 사용하기로 결정했습니다. 여러 다양한 도구중 ArgoCD 를 사용한 이유는 설치 및 사용이 쉽고 간편 했기 때문입니다.</p>
<p>또한 GitOps 구현체로서 반드시 필요한 기능만 갖고 있는 가벼운 느낌이 있었습니다. 또한 참고할수 있는 Reference 역시 많았습니다.</p>
<p>ArgoCD 뿐만 아니라 Blue/Green, Canary 등 배포 전략을 사용하기위해 Argo-rollouts 를 사용하였고, ArgoCD 의 Sync 상태와 등록된 Application의 상태를 Slack 을 통해 알림 받을수 있도록 ArgoCD-notification 도 사용하였습니다.</p>
<ul>
<li>ArgoCD: <a href="https://argoproj.github.io/argo-cd/" target="_blank" rel="nofollow noopener noreferrer">https://argoproj.github.io/argo-cd/</a></li>
<li>Argo-rollouts: <a href="https://argoproj.github.io/argo-rollouts/" target="_blank" rel="nofollow noopener noreferrer">https://argoproj.github.io/argo-rollouts/</a></li>
<li>ArgoCD-notifications: <a href="https://argoproj.github.io/argo-cd/operator-manual/notifications/" target="_blank" rel="nofollow noopener noreferrer">https://argoproj.github.io/argo-cd/operator-manual/notifications/</a></li>
</ul>
<p>각각에 대한 문서는 위와 같으며, 설치 방법이 쉽게 설명되어 있습니다.</p>
<h1 id="3-argocd-manifest-repository-연동"><a href="#3-argocd-manifest-repository-%EC%97%B0%EB%8F%99" aria-hidden="true"><span class="icon icon-link"></span></a>3. ArgoCD, Manifest Repository 연동</h1>
<p>ArgoCD 에 등록한 Application은 배포 목적지에 따라 그에 맞는 Branch, Directory 와 sync 하고 환경별 Values 파일을 참조합니다.</p>
<p>예를 들어 admin-api-gateway-qa Application 은 QA Branch 의 admin-api-gateway 디렉토리에 변경사항이 생겼을 경우 Sync 하며, qa.values.yaml 파일을 참조하여 Sync 합니다.</p>
<p><img src="https://miro.medium.com/max/700/1*oC-Zf_7aRDKIwyHHlGH_oA.png"></p>
<p><img src="https://miro.medium.com/max/700/1*UnrySLDIf5wwSj2OQ2aHKw.png"></p>
<h1 id="4-application-repository-와-manifest-repository-연동"><a href="#4-application-repository-%EC%99%80-manifest-repository-%EC%97%B0%EB%8F%99" aria-hidden="true"><span class="icon icon-link"></span></a>4. Application Repository 와 Manifest Repository 연동</h1>
<p>앞서 개선 방향 그림에서 설명하였듯이 Application Repository 의 Pipeline 은 빌드를 담당하고 빌드이후 Manifest Repository에 변경사항(이미지 tag) 을 적용하여야 합니다. 따라서 다음과 같은 명령어를 사용하여 Pipeline 에서 Manifest Repository 에 Commit 하도록 하였습니다.</p>
<pre class="language-zsh"><code class="language-zsh">- git clone https://$GIT_USER_NAME:$GIT_USER_PASSWORD@bitbucket.org/soomgo/kubernetes-manifest.git && cd kubernetes-manifest
- git config --global user.email $GIT_USER_EMAIL; git config --global user.name $GIT_USER_NAME ; git config --global push.default matching
- git fetch && git checkout qa
- sed -i 's/tag:.\*/tag:'' '\$BITBUCKET_COMMIT_SHORT'/g'
- \$CONTAINER_APP_NAME/qa.values.yaml
- if [ -z "$(git status --porcelain)" ];
  then
  echo "nothing to commit, working directory clean";
  else
  git commit -am "https://bitbucket.org/"$BITBUCKET_COMMIT_LINK && git push;
  fi</code></pre>
<h1 id="결과"><a href="#%EA%B2%B0%EA%B3%BC" aria-hidden="true"><span class="icon icon-link"></span></a>결과</h1>
<h3 id="1-application-repository-와-manifest-file-의-repository-완전히-분리"><a href="#1-application-repository-%EC%99%80-manifest-file-%EC%9D%98-repository-%EC%99%84%EC%A0%84%ED%9E%88-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="icon icon-link"></span></a>1. Application Repository 와 Manifest File 의 Repository 완전히 분리</h3>
<p>각각의 Repository 가 완전히 분리됨에 따라 기존의 문제점들이 사라졌습니다. 여러 Application 들의 Manifest File 들이 한 Repository 에서 관리 되기 때문에 설정파일 관리 측면에서도 이전보다 많이 수월해 졌습니다. 또한 Master Branch 에 대한 권한 설정으로 Production 환경 관리 측면에서 안정성을 높일수 있게 되었습니다.</p>
<h3 id="2-gitops-적용-완료"><a href="#2-gitops-%EC%A0%81%EC%9A%A9-%EC%99%84%EB%A3%8C" aria-hidden="true"><span class="icon icon-link"></span></a>2. GitOps 적용 완료</h3>
<p>Kubernetes 환경은 하나의 출처(source)인 Manifest Repository 에 의해서만 관리되게 되었습니다. 기존처럼 변경을 위해 CLI 를 직접 실행하는 일을막고 Git Commit 이 이를 대체할수 있게 되었습니다.</p>
<h3 id="3-배포-모니터링-개선-완료"><a href="#3-%EB%B0%B0%ED%8F%AC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B0%9C%EC%84%A0-%EC%99%84%EB%A3%8C" aria-hidden="true"><span class="icon icon-link"></span></a>3. 배포 모니터링 개선 완료</h3>
<p>ArgoCD 와 ArgoCD-notifications 를 사용 함으로서 배포에 대한 모니터링이 개선 되었습니다.
아래 그림처럼 ArgoCD 를 통해 상태에 대한 모니터링이 가능하며, 상태에 대한 알림을 Slack 을 통해 받을수 있습니다.</p>
<p><img src="https://miro.medium.com/max/700/1*GG8SjnYLau0dlIAWfGLd_Q.png"></p>
<p><img src="https://miro.medium.com/max/700/1*4V2exB9BtDUSK3HjcdEYHw.jpeg"></p>
<p><img src="https://miro.medium.com/max/700/1*3qau2A2IgB8eao01DSRvQw.png"></p>
<h1 id="맺음말"><a href="#%EB%A7%BA%EC%9D%8C%EB%A7%90" aria-hidden="true"><span class="icon icon-link"></span></a>맺음말</h1>
<p>CD (Continuous Deployment) 를 개선한 이유와 개선 방법, 결과에 대한 내용을 작성해 봤습니다. 모든 개선이 끝이 없는것처럼 위 내용도 끝이 아닌 새로운 시작인것 같습니다. 좀 더 운영해보며 문제점들을 찾아 지속적인 개선을 할 계획이고 CD 뿐 아니라 CI 측면에서도 지속적인 개선을 해나갈 생각입니다.</p>
<p>이후 개선작업 관련해서 공유할만 주제가 있다면 숨고 기술블로그를 통해 포스팅할 예정입니다.</p>
<p>부족한 글 읽어주셔서 감사합니다.</p>
</div></div></div></section><div class="box author"><figure class="image is-rounded is-128x128"><img src="../../../../../../uploads/author-images/derek.jpeg" class="is-rounded"></figure><div class="content"><h2 class="title is-5">
        Posted by <a href="/author/derek/">Derek</a></h2><p>Soomgo DevOps Engineer</p></div><!----><!----><!----><!----><!----><div class="posts"><div class="next">
        다음 게시글
        <p><a href="/blog/2021/04/07/website-benchmark-with-lighthouse/">
            Lighthouse로 웹사이트 성능 측정하기 by Zoey Kang</a></p></div><div class="previous">
        이전 게시글
        <p><a href="/blog/2020/12/09/auto-docs-with-swagger-and-redoc/">
            Swagger와 Redoc을 이용한 API 문서 자동화하기 by Paul Cho
          </a></p></div></div><!----><!----><!----></div></main><footer class="footer"><div class="content has-text-centered"><p>© 2021 SoomgoTech</p><p>
        Powered by GitHub Pages
      </p></div></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"posts":{"edges":[{"node":{"id":"ae5576a53167114266f6ab8c69cfe19f"},"prev":{"path":"\u002Fblog\u002F2021\u002F04\u002F26\u002Fmobile-app-deploy-automation\u002F","title":"모바일 앱 매주 배포하기: 자동화하기","author":{"title":"Jimmy Lee","path":"\u002Fauthor\u002Fjimmy-lee\u002F"}},"next":null},{"node":{"id":"48ed018164c43aeb8996774e3f8f6c22"},"prev":{"path":"\u002Fblog\u002F2021\u002F04\u002F18\u002Fmobile-app-deploy-create-rule\u002F","title":"모바일 앱 매주 배포하기: 규칙 정하기","author":{"title":"Jimmy Lee","path":"\u002Fauthor\u002Fjimmy-lee\u002F"}},"next":{"path":"\u002Fblog\u002F2021\u002F05\u002F20\u002Fabout-fundamental-of-agile\u002F","title":"애자일의 근본 알아보기","author":{"title":"Jimmy Lee","path":"\u002Fauthor\u002Fjimmy-lee\u002F"}}},{"node":{"id":"29c698b6f384ebf2384dbd2640cf91c2"},"prev":{"path":"\u002Fblog\u002F2021\u002F04\u002F16\u002Fsquad-process-and-product-designer\u002F","title":"[Design] 숨고의 애자일, 스쿼드의 업무 프로세스와 프로덕트 디자이너가 하는 일","author":{"title":"Summer Lee","path":"\u002Fauthor\u002Fsummer-lee\u002F"}},"next":{"path":"\u002Fblog\u002F2021\u002F04\u002F26\u002Fmobile-app-deploy-automation\u002F","title":"모바일 앱 매주 배포하기: 자동화하기","author":{"title":"Jimmy Lee","path":"\u002Fauthor\u002Fjimmy-lee\u002F"}}},{"node":{"id":"beec0a16612692a60906c5d0794787b2"},"prev":{"path":"\u002Fblog\u002F2021\u002F04\u002F07\u002Fwebsite-benchmark-with-lighthouse\u002F","title":"Lighthouse로 웹사이트 성능 측정하기","author":{"title":"Zoey Kang","path":"\u002Fauthor\u002Fzoey-kang\u002F"}},"next":{"path":"\u002Fblog\u002F2021\u002F04\u002F18\u002Fmobile-app-deploy-create-rule\u002F","title":"모바일 앱 매주 배포하기: 규칙 정하기","author":{"title":"Jimmy Lee","path":"\u002Fauthor\u002Fjimmy-lee\u002F"}}},{"node":{"id":"b55c21505707bfeb0c3e200227e80b50"},"prev":{"path":"\u002Fblog\u002F2020\u002F12\u002F18\u002Fimprove-kubernetes-cd\u002F","title":"Kubernetes 환경 CD(Continuous Deployment) 개선하기","author":{"title":"Derek","path":"\u002Fauthor\u002Fderek\u002F"}},"next":{"path":"\u002Fblog\u002F2021\u002F04\u002F16\u002Fsquad-process-and-product-designer\u002F","title":"[Design] 숨고의 애자일, 스쿼드의 업무 프로세스와 프로덕트 디자이너가 하는 일","author":{"title":"Summer Lee","path":"\u002Fauthor\u002Fsummer-lee\u002F"}}},{"node":{"id":"985f56840e2f22845987f529305dfc2f"},"prev":{"path":"\u002Fblog\u002F2020\u002F12\u002F09\u002Fauto-docs-with-swagger-and-redoc\u002F","title":"Swagger와 Redoc을 이용한 API 문서 자동화하기","author":{"title":"Paul Cho","path":"\u002Fauthor\u002Fpaul-cho\u002F"}},"next":{"path":"\u002Fblog\u002F2021\u002F04\u002F07\u002Fwebsite-benchmark-with-lighthouse\u002F","title":"Lighthouse로 웹사이트 성능 측정하기","author":{"title":"Zoey Kang","path":"\u002Fauthor\u002Fzoey-kang\u002F"}}},{"node":{"id":"dda2ca28bab0299deec8a89a846e6d48"},"prev":{"path":"\u002Fblog\u002F2020\u002F11\u002F02\u002Fsoomgo-msa-architecture-soomgo-py\u002F","title":"숨고의 MSA Architecture를 위한 프레임워크 Soomgo-py","author":{"title":"Paul Cho","path":"\u002Fauthor\u002Fpaul-cho\u002F"}},"next":{"path":"\u002Fblog\u002F2020\u002F12\u002F18\u002Fimprove-kubernetes-cd\u002F","title":"Kubernetes 환경 CD(Continuous Deployment) 개선하기","author":{"title":"Derek","path":"\u002Fauthor\u002Fderek\u002F"}}},{"node":{"id":"d7c5f4fc0af185befef675bf903b0cc7"},"prev":{"path":"\u002Fblog\u002F2020\u002F09\u002F29\u002Fhttp2-for-all\u002F","title":"모두를 위한 Http2","author":{"title":"Kei Jeon","path":"\u002Fauthor\u002Fkei-jeon\u002F"}},"next":{"path":"\u002Fblog\u002F2020\u002F12\u002F09\u002Fauto-docs-with-swagger-and-redoc\u002F","title":"Swagger와 Redoc을 이용한 API 문서 자동화하기","author":{"title":"Paul Cho","path":"\u002Fauthor\u002Fpaul-cho\u002F"}}},{"node":{"id":"bb8fc898b05cf4e28cc2cb9252d551dc"},"prev":null,"next":{"path":"\u002Fblog\u002F2020\u002F11\u002F02\u002Fsoomgo-msa-architecture-soomgo-py\u002F","title":"숨고의 MSA Architecture를 위한 프레임워크 Soomgo-py","author":{"title":"Paul Cho","path":"\u002Fauthor\u002Fpaul-cho\u002F"}}}]},"post":{"id":"985f56840e2f22845987f529305dfc2f","title":"Kubernetes 환경 CD(Continuous Deployment) 개선하기","excerpt":"About Kubernetes CD","featuredImage":"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*Z-TOA6-TpZEyZj0q7C4dWQ.jpeg","content":"\u003Cp\u003E안녕하세요. 숨고 DevOps 엔지니어 Derek 입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E최근 진행한 Kubernetes 환경에 대한 CD(Continuous Deployment)개선에 대하여 개선 이유, 작업 내용, 결과를 포스팅 해보려 합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E동일한 고민을 갖고있을 DevOps 엔지니어 또는 개발자에게 조금이나마 도움이 되길 바랍니다.\u003C\u002Fp\u003E\n\u003Ch1 id=\"1-배경-설명\"\u003E\u003Ca href=\"#1-%EB%B0%B0%EA%B2%BD-%EC%84%A4%EB%AA%85\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. 배경 설명\u003C\u002Fh1\u003E\n\u003Cp\u003E숨고 서비스를 지탱하는 Application 중 다수의 것들이 Kubernetes 환경에서 운영되고 있습니다. MSA Architecture 로 설계 되어 있으며, 때문에 잘게 나누어진 Application Repository 가 존재합니다. Kubernetes 에 배포를 위한 Manifest 파일은 해당 Application Repository 에 함께 존재했습니다.\n숨고는 CI\u002FCD 를 위해 Bitbucket Pipeline 을 사용하고 있습니다. 때문에 도커 이미지 빌드, Kubernetes 배포 또한 Bitbucket Pipeline 을 통하여 진행됩니다. 또한 무 중단 배포를 위한 Blue\u002FGreen 배포 스크립트가 존재하고 Bitbucket Pipeline 에서 해당 스크립트를 실행하여 배포하게 됩니다.\u003C\u002Fp\u003E\n\u003Ch1 id=\"2-개선-이유\"\u003E\u003Ca href=\"#2-%EA%B0%9C%EC%84%A0-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. 개선 이유\u003C\u002Fh1\u003E\n\u003Ch3 id=\"21-application-code-와-manifest-file-의-repository-분리\"\u003E\u003Ca href=\"#21-application-code-%EC%99%80-manifest-file-%EC%9D%98-repository-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2–1. Application Code 와 Manifest File 의 Repository 분리\u003C\u002Fh3\u003E\n\u003Cp\u003E앞서 배경 설명에서 언급 하였듯이 Application Code 와 Manifest 파일이 동일한 Repository 에서 관리 되었습니다. 이는 다음과 같은 단점을 갖고 있었고 이를 분리하여 문제를 해결하고자 했습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EManifest File 만 변경시에도 안전한 배포(무중단)를 위해서는 컨테이너 빌드 절차를 거쳐야함. (Kubernetes에서 변경이 있을경우 Rollout 되는 항목에 한하여)\u003C\u002Fli\u003E\n\u003Cli\u003EManifest File 이 여러 Application Repository 에 분산되어 관리가 어려움.\u003C\u002Fli\u003E\n\u003Cli\u003EApplication Code 변경 로그와 Manifest 변경 로그가 뒤섞여 가시성 떨어짐.\u003C\u002Fli\u003E\n\u003Cli\u003ERepository 수정 권한이 있는 모든 인원이 Manifest 파일을 수정하고 이를 Production 까지 적용할 수 있어 안정성이 떨어짐.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-2-gitops-적용\"\u003E\u003Ca href=\"#2-2-gitops-%EC%A0%81%EC%9A%A9\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2-2. GitOps 적용\u003C\u002Fh3\u003E\n\u003Cp\u003EGitOps 란 Kubernetes 클러스터를 관리하고 Application 을 배포하는 방법론이며, 이것은 선언적 인프라와 Application을 위해 Git 을 단일 소스(single source of truth) 로 사용하는것을 말합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E즉, 설정파일 관리 Repository (Git) 을 통해서만(단일한 방법) Kuberentes 클러스터가 변경되고 Application이 배포되는 것입니다.\u003C\u002Fp\u003E\n\u003Cp\u003EGitOps 적용으로 인한 장점은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EGit Repository의 현재 상태만 확인하면 Kubernetes 클러스터의 상태를 쉽게 확인가능.\u003C\u002Fli\u003E\n\u003Cli\u003E모든 설정 정보 변경이 Git의 버전으로 관리됨.\u003C\u002Fli\u003E\n\u003Cli\u003Ekubectl, helm 등의 명령어를 사용자가 직접 실행하는 것이 아니기 때문에 휴먼 에러를 방지하며 안정적으로 상태를 변경하고 배포할수 있음.\u003C\u002Fli\u003E\n\u003Cli\u003ERepository 권한 설정으로 Kubernetes 클러스터 접근 권한 분리 가능.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E이와 같은 장점을 위해 GitOps를 적용하고자 했습니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"2-3-배포-모니터링-개선\"\u003E\u003Ca href=\"#2-3-%EB%B0%B0%ED%8F%AC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B0%9C%EC%84%A0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2-3. 배포 모니터링 개선\u003C\u002Fh3\u003E\n\u003Cp\u003E현 배포 시스템의 경우(Bitbucket Pipeline) Kubernetes에 명령을 실행한후 적용이 완료 되었는지 또는 실패 하였는지 등의 모니터링이 되지 않습니다.\u003C\u002Fp\u003E\n\u003Cp\u003EArgoCD 를 사용하여 배포 모니터링을 개선하고자 하였습니다.\u003C\u002Fp\u003E\n\u003Ch1 id=\"3-작업-내용\"\u003E\u003Ca href=\"#3-%EC%9E%91%EC%97%85-%EB%82%B4%EC%9A%A9\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. 작업 내용\u003C\u002Fh1\u003E\n\u003Ch3 id=\"31-개선-방향-설정\"\u003E\u003Ca href=\"#31-%EA%B0%9C%EC%84%A0-%EB%B0%A9%ED%96%A5-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3–1. 개선 방향 설정\u003C\u002Fh3\u003E\n\u003Cp\u003E앞서 얘기한 현시점의 배포 문제점과 새로 제안한 개선점들을 통하여 실제 작업 내용을 Flow Chart로 만들어봤습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E아래 As-Is, To-Be Flow 그림에서 확인할 수 있듯이 Repository 를 분리하고 Manifest Repository 에 변경이 발생하였을때 ArgoCD 에서 이를 감지하여 Sync (배포 or 변경) 하고자 하였습니다.\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EAs-Is flow\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*Z-TOA6-TpZEyZj0q7C4dWQ.jpeg\"\u003E\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003ETo-Be flow\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*5Cs42Py-NVIQsOtoXxlCyA.jpeg\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"3-2-manifest-repository-생성\"\u003E\u003Ca href=\"#3-2-manifest-repository-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3-2. Manifest Repository 생성\u003C\u002Fh3\u003E\n\u003Cp\u003EApplication Respository 에서 Manifest 를 분리하기 위해 통합된 Manifest Repository 를 생성하였습니다. 해당 Repository 는 Helm Chart 를 사용하여 구조화 하였습니다.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E├── api-gateway #Application 별 Directory\n│ ├── Chart.yaml\n│ ├── charts\n│ ├── dev.values.yaml #환경별 Values 파일\n│ ├── prod.values.yaml\n│ ├── qa.values.yaml\n│ ├── staging.values.yaml\n│ ├── templates #Application Templates\n│ │ ├── deployment.yaml\n│ │ ├── hpa.yaml\n│ │ ├── ingress.yaml\n│ │ ├── service-standby.yaml\n│ │ └── service.yaml\n│ └── test.values.yaml\n....\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E해당 Repository 는 배포 환경별 Branch 가 존재합니다. 예를 들어 Staging 배포를 위한 staging branch, QA 환경 배포를 위한 QA branch, Production 배포를 위한 Master branch 와 같은 형태입니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"3-2-argocd-argo-rollouts-argocd-notifications-사용\"\u003E\u003Ca href=\"#3-2-argocd-argo-rollouts-argocd-notifications-%EC%82%AC%EC%9A%A9\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3-2. ArgoCD, Argo-rollouts, ArgoCD-notifications 사용\u003C\u002Fh3\u003E\n\u003Cp\u003E앞서 언급 하였듯이 배포 개선을 하기위하여 GitOps 의 구현체로 ArgoCD 를 사용하기로 결정했습니다. 여러 다양한 도구중 ArgoCD 를 사용한 이유는 설치 및 사용이 쉽고 간편 했기 때문입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E또한 GitOps 구현체로서 반드시 필요한 기능만 갖고 있는 가벼운 느낌이 있었습니다. 또한 참고할수 있는 Reference 역시 많았습니다.\u003C\u002Fp\u003E\n\u003Cp\u003EArgoCD 뿐만 아니라 Blue\u002FGreen, Canary 등 배포 전략을 사용하기위해 Argo-rollouts 를 사용하였고, ArgoCD 의 Sync 상태와 등록된 Application의 상태를 Slack 을 통해 알림 받을수 있도록 ArgoCD-notification 도 사용하였습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EArgoCD: \u003Ca href=\"https:\u002F\u002Fargoproj.github.io\u002Fargo-cd\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fargoproj.github.io\u002Fargo-cd\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EArgo-rollouts: \u003Ca href=\"https:\u002F\u002Fargoproj.github.io\u002Fargo-rollouts\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fargoproj.github.io\u002Fargo-rollouts\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EArgoCD-notifications: \u003Ca href=\"https:\u002F\u002Fargoproj.github.io\u002Fargo-cd\u002Foperator-manual\u002Fnotifications\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fargoproj.github.io\u002Fargo-cd\u002Foperator-manual\u002Fnotifications\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E각각에 대한 문서는 위와 같으며, 설치 방법이 쉽게 설명되어 있습니다.\u003C\u002Fp\u003E\n\u003Ch1 id=\"3-argocd-manifest-repository-연동\"\u003E\u003Ca href=\"#3-argocd-manifest-repository-%EC%97%B0%EB%8F%99\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. ArgoCD, Manifest Repository 연동\u003C\u002Fh1\u003E\n\u003Cp\u003EArgoCD 에 등록한 Application은 배포 목적지에 따라 그에 맞는 Branch, Directory 와 sync 하고 환경별 Values 파일을 참조합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E예를 들어 admin-api-gateway-qa Application 은 QA Branch 의 admin-api-gateway 디렉토리에 변경사항이 생겼을 경우 Sync 하며, qa.values.yaml 파일을 참조하여 Sync 합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*oC-Zf_7aRDKIwyHHlGH_oA.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*UnrySLDIf5wwSj2OQ2aHKw.png\"\u003E\u003C\u002Fp\u003E\n\u003Ch1 id=\"4-application-repository-와-manifest-repository-연동\"\u003E\u003Ca href=\"#4-application-repository-%EC%99%80-manifest-repository-%EC%97%B0%EB%8F%99\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E4. Application Repository 와 Manifest Repository 연동\u003C\u002Fh1\u003E\n\u003Cp\u003E앞서 개선 방향 그림에서 설명하였듯이 Application Repository 의 Pipeline 은 빌드를 담당하고 빌드이후 Manifest Repository에 변경사항(이미지 tag) 을 적용하여야 합니다. 따라서 다음과 같은 명령어를 사용하여 Pipeline 에서 Manifest Repository 에 Commit 하도록 하였습니다.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-zsh\"\u003E\u003Ccode class=\"language-zsh\"\u003E- git clone https:\u002F\u002F$GIT_USER_NAME:$GIT_USER_PASSWORD@bitbucket.org\u002Fsoomgo\u002Fkubernetes-manifest.git && cd kubernetes-manifest\n- git config --global user.email $GIT_USER_EMAIL; git config --global user.name $GIT_USER_NAME ; git config --global push.default matching\n- git fetch && git checkout qa\n- sed -i 's\u002Ftag:.\\*\u002Ftag:'' '\\$BITBUCKET_COMMIT_SHORT'\u002Fg'\n- \\$CONTAINER_APP_NAME\u002Fqa.values.yaml\n- if [ -z \"$(git status --porcelain)\" ];\n  then\n  echo \"nothing to commit, working directory clean\";\n  else\n  git commit -am \"https:\u002F\u002Fbitbucket.org\u002F\"$BITBUCKET_COMMIT_LINK && git push;\n  fi\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch1 id=\"결과\"\u003E\u003Ca href=\"#%EA%B2%B0%EA%B3%BC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E결과\u003C\u002Fh1\u003E\n\u003Ch3 id=\"1-application-repository-와-manifest-file-의-repository-완전히-분리\"\u003E\u003Ca href=\"#1-application-repository-%EC%99%80-manifest-file-%EC%9D%98-repository-%EC%99%84%EC%A0%84%ED%9E%88-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. Application Repository 와 Manifest File 의 Repository 완전히 분리\u003C\u002Fh3\u003E\n\u003Cp\u003E각각의 Repository 가 완전히 분리됨에 따라 기존의 문제점들이 사라졌습니다. 여러 Application 들의 Manifest File 들이 한 Repository 에서 관리 되기 때문에 설정파일 관리 측면에서도 이전보다 많이 수월해 졌습니다. 또한 Master Branch 에 대한 권한 설정으로 Production 환경 관리 측면에서 안정성을 높일수 있게 되었습니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"2-gitops-적용-완료\"\u003E\u003Ca href=\"#2-gitops-%EC%A0%81%EC%9A%A9-%EC%99%84%EB%A3%8C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. GitOps 적용 완료\u003C\u002Fh3\u003E\n\u003Cp\u003EKubernetes 환경은 하나의 출처(source)인 Manifest Repository 에 의해서만 관리되게 되었습니다. 기존처럼 변경을 위해 CLI 를 직접 실행하는 일을막고 Git Commit 이 이를 대체할수 있게 되었습니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"3-배포-모니터링-개선-완료\"\u003E\u003Ca href=\"#3-%EB%B0%B0%ED%8F%AC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EA%B0%9C%EC%84%A0-%EC%99%84%EB%A3%8C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. 배포 모니터링 개선 완료\u003C\u002Fh3\u003E\n\u003Cp\u003EArgoCD 와 ArgoCD-notifications 를 사용 함으로서 배포에 대한 모니터링이 개선 되었습니다.\n아래 그림처럼 ArgoCD 를 통해 상태에 대한 모니터링이 가능하며, 상태에 대한 알림을 Slack 을 통해 받을수 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*GG8SjnYLau0dlIAWfGLd_Q.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*4V2exB9BtDUSK3HjcdEYHw.jpeg\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F700\u002F1*3qau2A2IgB8eao01DSRvQw.png\"\u003E\u003C\u002Fp\u003E\n\u003Ch1 id=\"맺음말\"\u003E\u003Ca href=\"#%EB%A7%BA%EC%9D%8C%EB%A7%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E맺음말\u003C\u002Fh1\u003E\n\u003Cp\u003ECD (Continuous Deployment) 를 개선한 이유와 개선 방법, 결과에 대한 내용을 작성해 봤습니다. 모든 개선이 끝이 없는것처럼 위 내용도 끝이 아닌 새로운 시작인것 같습니다. 좀 더 운영해보며 문제점들을 찾아 지속적인 개선을 할 계획이고 CD 뿐 아니라 CI 측면에서도 지속적인 개선을 해나갈 생각입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이후 개선작업 관련해서 공유할만 주제가 있다면 숨고 기술블로그를 통해 포스팅할 예정입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E부족한 글 읽어주셔서 감사합니다.\u003C\u002Fp\u003E\n","tags":[{"id":"Development"},{"id":"DevOps"},{"id":"CI\u002FCD"}],"author":{"path":"\u002Fauthor\u002Fderek\u002F","title":"Derek","image":"uploads\u002Fauthor-images\u002Fderek.jpeg","blurb":"Soomgo DevOps Engineer"}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.fa1010ad.js" defer></script><script src="/assets/js/page--src--templates--post-vue.77e0a7ac.js" defer></script>
  </body>
</html>
